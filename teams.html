<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>FTG X9000</title>
  <style>
    :root{
      --bg:#ffffff;
      --panel:#ffffff;
      --muted:#6b7280; /* gray-500 */
      --text:#111827;  /* gray-900 */
      --accent:#2563eb; /* blue-600 */
      --accent-2:#059669; /* emerald-600 */
      --danger:#dc2626; /* red-600 */
      --warn:#b45309;   /* amber-700 */
      --border:#e5e7eb; /* gray-200 */
      --focus:#2563eb;  /* blue-600 */
    }
    /* Ensure hidden attribute truly hides on all browsers */
    [hidden]{ display:none !important }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;
      background: radial-gradient(1200px 800px at 10% 10%, #e5f0ff 0%, #f8fafc 60%);
      color:var(--text);
    }
    header{
      display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap;
      gap:12px; padding:18px 20px; border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7));
      backdrop-filter: blur(6px);
      position:sticky; top:0; z-index:2;
    }
    header h1{margin:0; font-size:20px; letter-spacing:.2px}
    .btn{
      appearance:none; border:1px solid #d1d5db; background:#ffffff; color:#111827;
      padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; letter-spacing:.2px;
      box-shadow: 0 1px 1px rgba(0,0,0,.04);
      min-height:44px; font-size:16px; line-height:1.2;
      touch-action: manipulation;
    }
    .btn:hover{border-color:#9ca3af; background:#f9fafb}
    .btn[disabled]{opacity:.6; cursor:not-allowed}
    .btn.primary{background:linear-gradient(180deg, #3b82f6, #2563eb); border-color:#2563eb; color:#fff}
    .btn.danger{background:linear-gradient(180deg, #ef4444, #dc2626); border-color:#b91c1c; color:#fff}
    .btn.secondary{background:#f3f4f6}

    main{padding:18px 20px; max-width:1100px; margin:0 auto}

    /* Tabs */
    .tabs{
      position:sticky; top:62px; z-index:2; /* under header */
      display:flex; gap:8px; padding:8px 12px; border-bottom:1px solid var(--border);
      background:linear-gradient(180deg, rgba(255,255,255,0.95), rgba(255,255,255,0.9));
      backdrop-filter: blur(6px);
    }
    .tab{
      flex:1; min-height:44px; padding:10px 12px; border-radius:999px; border:1px solid var(--border);
      background:#fff; color:#111827; font-weight:600; cursor:pointer;
    }
    .tab.active{ border-color:#2563eb; color:#0b3aa8; box-shadow: inset 0 0 0 1px #2563eb }
    .tab[disabled]{ opacity:.5; cursor:not-allowed }

    .picker{
      display:grid; grid-template-columns:1fr; gap:16px; align-items:start;
    }
    @media (min-width: 900px){
      .picker{grid-template-columns:1fr 1fr}
    }
    .panel{background:var(--panel); border:1px solid var(--border); border-radius:12px; padding:12px}
    .panel h2{margin:0 0 8px 0; font-size:14px; color:var(--muted); font-weight:700; text-transform:uppercase}
    .counts{font-size:12px; color:var(--muted)}

    .search{
      width:100%; margin:8px 0 10px 0; padding:12px 12px; border-radius:10px; border:1px solid #d1d5db;
      background:#ffffff; color:var(--text); font-size:16px; min-height:44px;
    }
    .lists{display:flex; flex-direction:column; gap:8px; max-height:360px; overflow:auto; padding:2px; -webkit-overflow-scrolling:touch; overscroll-behavior:contain}
    .item{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:12px 14px; border:1px solid var(--border); border-radius:10px; background:#ffffff; min-height:44px}
    .item button{background:transparent; color:#6b7280; border:none; padding:6px; cursor:pointer; font-size:18px}
    .item button:hover{color:#111827}
    .item[draggable="true"]{cursor:grab}
    .item:focus-visible{outline:2px solid var(--focus); outline-offset:2px}
    .droptarget{outline:2px dashed var(--accent); outline-offset:-4px}

    .notice{margin-top:6px; color:var(--muted); font-size:12px}
    .error{color:var(--danger)}

    .actions{display:flex; gap:8px; align-items:center; justify-content:flex-end; margin:12px 0}

    .teams{margin-top:20px}
    .teams header{display:flex; justify-content:space-between; align-items:center; gap:8px; padding:0; border:0; background:transparent; position:static}
    table{width:100%; border-collapse:collapse; overflow:hidden; border-radius:12px; border:1px solid var(--border); background:#fff}
    th, td{padding:10px 12px; border-bottom:1px solid var(--border); vertical-align:top}
    th{font-size:12px; color:var(--muted); text-transform:uppercase; text-align:left}
    tbody tr:last-child td{border-bottom:none}
    .swatch{width:16px; height:16px; border-radius:50%; display:inline-block; border:1px solid rgba(0,0,0,.15)}
    .team-name[contenteditable="true"]{padding:2px 6px; border-radius:6px}
    .team-name[contenteditable="true"]:focus{outline:2px solid var(--focus)}
    .team-pill{ display:inline-flex; align-items:center; gap:8px; padding:4px 8px; border-radius:999px; border:1px solid #e5e7eb; background:#fff; align-self:flex-start }
    .team-pill .pill-swatch{ width:14px; height:14px; border-radius:50%; border:1px solid rgba(0,0,0,.15); display:inline-block }
    .team-sub{ display:block; margin-top:4px; font-size:11px; color:var(--muted); }
    .team-pill.winner{ color:#fff; }
    .gd-pos{ color: var(--accent-2); }
    .gd-neg{ color: var(--danger); }
    /* Teams: vertically center cells */
    #teamsSection table th,
    #teamsSection table td{ vertical-align: middle }

    /* Leaderboard: vertically center stats cells */
    #leaderboardSection table th,
    #leaderboardSection table td{ vertical-align: middle }

    .schedule{margin-top:16px}
    .pair{padding:10px 12px; border:1px solid var(--border); border-radius:8px; background:#ffffff; margin-top:8px}
    .pair.played{ opacity:.6 }
    .match-score{ text-align:right; margin-left:auto; display:flex; align-items:center; justify-content:flex-end; gap:8px }
    /* Next match highlighting */
    .pair.next{ border-color:#2563eb; border-width:2px }
    .next-heading{ color:#2563eb; font-weight:800; letter-spacing:.2px; margin:8px 0 4px 0 }
    /* Matches: show players by default; stacked layout handled in JS */
    @media (max-width:600px){ .match-score{ flex-direction:column; gap:4px } }
    /* Breathing room under panel headers in Players tab */
    #playersSection .panel > div:first-child{ margin-bottom: 10px }

    footer{margin:24px 0; color:var(--muted); font-size:12px}

    /* Mobile optimizations */
    @media (max-width: 899px){
      header{padding:14px 12px}
      .tabs{ top:54px; padding:6px 8px }
      main{padding:14px 12px}
      .lists{max-height:40vh}
      .actions{
        position: sticky; bottom: env(safe-area-inset-bottom, 0px);
        background: linear-gradient(180deg, rgba(255,255,255,0), rgba(255,255,255,0.95));
        border-top:1px solid var(--border);
        padding:10px 8px calc(10px + env(safe-area-inset-bottom, 0px));
        margin-left:-8px; margin-right:-8px;
      }
      .actions .btn.primary{flex:1}
      .panel{border-radius:12px}
      .item{border-radius:12px}
      /* Compact steppers on mobile */
      .btn.step{ min-width:32px; min-height:32px; font-size:18px }
      .score-input{ width:48px !important; min-height:32px; font-size:16px }
      .modal .score-stepper{ gap:6px; margin:0 6px }
    }

    /* Modal */
    .modal-overlay[hidden], .modal[hidden]{ display:none }
    .modal-overlay{
      position: fixed; inset: 0; background: rgba(0,0,0,.35); z-index: 50;
      backdrop-filter: blur(2px);
    }
    .modal{
      position: fixed; z-index: 51; left:50%; top: 10vh; transform: translateX(-50%);
      width: min(92vw, 480px); background: #fff; border:1px solid var(--border); border-radius:12px;
      box-shadow: 0 20px 40px rgba(0,0,0,.12);
      display:flex; flex-direction:column; max-height:85vh; overflow:hidden;
    }
    .modal .modal-header{ padding:14px 16px; border-bottom:1px solid var(--border); position:sticky; top:0; background:#fff; z-index:1 }
    .modal .modal-body{ padding:14px 16px; flex:1 1 auto; overflow:auto; -webkit-overflow-scrolling:touch }
    .modal .modal-actions{ display:flex; justify-content:flex-end; gap:8px; padding:12px 16px; border-top:1px solid var(--border); position:sticky; bottom:0; background:#fff; z-index:1 }
    .modal .modal-fields{ display:grid; grid-template-columns:1fr; gap:12px }
    .modal .modal-fields label{ display:flex; align-items:center; justify-content:space-between; gap:12px; padding:0 6px }
    /* In modals, keep numeric inputs compact but text inputs full-width */
    .modal .modal-fields input[type="number"]{ width:100px }
    .modal .modal-fields input[type="text"],
    .modal .modal-fields input[type="search"]{ width:100% }
    .modal .score-row{ display:grid; grid-template-columns:1fr auto; align-items:center; gap:12px }
    .modal .score-stepper{ display:flex; align-items:center; gap:8px; margin:0 6px }
    .btn.step{ min-width:36px; min-height:36px; border-radius:10px; font-size:20px; padding:0; line-height:1; display:inline-flex; align-items:center; justify-content:center }
    .score-input{ width:56px !important; min-height:36px; text-align:center; font-size:18px; border:1px solid #d1d5db; border-radius:8px; background:#fff; color:#111827 }
    /* Big toggle switch */
    .switch{ display:flex; align-items:center; gap:10px; padding:0 6px }
    .switch input{ position:absolute; opacity:0; width:1px; height:1px; overflow:hidden }
    .switch .slider{ position:relative; width:54px; height:30px; background:#e5e7eb; border-radius:9999px; box-shadow: inset 0 0 0 1px #d1d5db; flex:0 0 auto }
    .switch .slider::after{ content:""; position:absolute; top:3px; left:3px; width:24px; height:24px; background:#fff; border-radius:50%; box-shadow: 0 1px 2px rgba(0,0,0,.2) }
    .switch input:focus-visible + .slider{ outline:2px solid var(--focus); outline-offset:2px }
    .switch input:checked + .slider{ background:#2563eb; box-shadow: inset 0 0 0 1px #2563eb }
    .switch input:checked + .slider::after{ transform: translateX(24px) }
    .switch .switch-text{ font-size:14px }
    .scorers{ margin-top:8px; display:grid; grid-template-columns:1fr; gap:12px }
    .scorer-card{ border:1px solid var(--border); border-radius:8px; padding:8px }
    .scorer-title{ font-size:12px; font-weight:700; color:var(--muted); margin-bottom:6px; text-transform:uppercase }
    .scorer-row{ display:flex; align-items:center; justify-content:space-between; gap:8px; margin:4px 0 }
    .scorer-input{ width:44px; min-height:28px; text-align:center; font-size:14px; border:1px solid #d1d5db; border-radius:6px }
    .btn.mini-step{ min-width:28px; min-height:28px; border-radius:8px; font-size:16px; padding:0; line-height:1; display:inline-flex; align-items:center; justify-content:center }

    /* Toast & Confetti */
    .toast{
      position: fixed; left:50%; bottom: calc(16px + env(safe-area-inset-bottom, 0px)); transform: translateX(-50%);
      background: #fff; color:#111827; border:1px solid #e5e7eb; border-radius:14px; padding:12px 16px; z-index:60;
      box-shadow: 0 10px 30px rgba(0,0,0,.15); font-weight:700; display:flex; gap:10px; align-items:center;
    }
    .toast .emoji{ font-size:22px }
    .toast.winner{ font-size:22px; padding:16px 20px; border-width:2px }
    .winner-banner{ font-size:28px; font-weight:800; text-align:center; color:#111827; letter-spacing:.5px; margin:8px 0 12px }
    .confetti{ position: fixed; top:-10px; width:8px; height:14px; opacity:.9; z-index:55; pointer-events:none }
    @keyframes confetti-fall{ from{ transform: translateY(-10vh) rotate(0deg)} to{ transform: translateY(110vh) rotate(360deg)} }

    /* Players tab locked state */
    #playersSection.locked .panel{ opacity:.5; pointer-events:none }
    #playersSection .locked-msg{ display:none; background:#fff8e1; border:1px solid #fde68a; color:#b45309; padding:10px 12px; border-radius:8px; font-weight:700; margin:0 0 8px 0 }
    #playersSection.locked .locked-msg{ display:block }
  </style>
</head>
<body>
  <header>
    <h1>FTG X9000</h1>
    <div style="display:flex; gap:8px; align-items:center">
      <button class="btn danger" id="btnReset" aria-label="Reset all match data">Reset</button>
    </div>
  </header>
  <nav class="tabs" role="tablist" aria-label="Futsal sections">
    <button id="tabPlayers" class="tab active" role="tab" aria-selected="true" aria-controls="playersSection">Players</button>
    <button id="tabTeams" class="tab" role="tab" aria-selected="false" aria-controls="teamsSection" disabled>Teams</button>
    <button id="tabMatches" class="tab" role="tab" aria-selected="false" aria-controls="matchesSection">Matches</button>
    <button id="tabLeaderboard" class="tab" role="tab" aria-selected="false" aria-controls="leaderboardSection">Leaderboard</button>
  </nav>
  <main>
    <section id="playersSection" class="picker" role="tabpanel" aria-labelledby="tabPlayers">
      <div id="playersLockedMsg" class="locked-msg" aria-live="polite"></div>
      <div class="panel" aria-labelledby="available-title">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px">
          <h2 id="available-title">Available Players <span class="counts" id="countNot">(0)</span></h2>
          <button id="btnAddPlayer" class="btn" type="button" aria-label="Add New Player">Add New Player</button>
        </div>
        <div id="listNot" class="lists" role="list" aria-label="Available players list"></div>
      </div>

      <div class="panel" aria-labelledby="playing-title">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:8px">
          <h2 id="playing-title">Playing Today <span class="counts" id="countPlay">(0/16)</span></h2>
        </div>
        <div id="listPlay" class="lists" role="list" aria-label="Playing list"></div>
        <div id="limitNotice" class="notice" role="status" aria-live="polite" style="display:none">Limit reached: maximum 16 attendees.</div>
      </div>
      <div class="actions" id="playersActions">
        <div id="genError" class="notice error" role="alert" style="margin-right:auto; display:none"></div>
        <button class="btn primary" id="btnGenerateBottom" aria-label="Generate balanced teams (bottom)" disabled>Generate Teams</button>
      </div>
    </section>

    <section class="teams" id="teamsSection" role="tabpanel" aria-labelledby="tabTeams" hidden>
      <header>
        <h2 style="margin:0">Teams</h2>
      </header>
      <div style="overflow:auto">
        <table aria-label="Teams table" id="teamsTable">
          <thead>
            <tr>
              <th>Team</th>
              <th>Members</th>
              <th>Size</th>
            </tr>
          </thead>
          <tbody id="teamsBody"></tbody>
        </table>
      </div>

    </section>

    <section class="schedule" id="matchesSection" role="tabpanel" aria-labelledby="tabMatches" hidden>
      <h2 style="margin:0 0 8px 0">Matches</h2>
      <div id="matchesList"></div>
    </section>

    <section id="leaderboardSection" role="tabpanel" aria-labelledby="tabLeaderboard" hidden>
      <!-- Leaderboard content rendered by JS -->
    </section>

    
  </main>

  <!-- Modal for setting match results -->
  <div id="overlay" class="modal-overlay" hidden></div>
  <div id="resultModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle" hidden>
    <div class="modal-header">
      <h3 id="modalTitle" style="margin:0; font-size:18px">Set Result</h3>
    </div>
    <div class="modal-body">
      <div id="modalMatchLabel" class="notice" style="margin-bottom:8px"></div>
      <div class="modal-fields">
        <label class="score-row">
          <span id="modalTeamAName" style="min-width:120px"></span>
          <div class="score-stepper">
            <button id="modalATeamMinus" class="btn step" type="button" aria-label="Decrease goals">−</button>
            <input id="modalTeamAScore" class="score-input" type="number" inputmode="numeric" min="0" placeholder="0" aria-label="Team A goals" />
            <button id="modalATeamPlus" class="btn step" type="button" aria-label="Increase goals">+</button>
          </div>
        </label>
        <label class="score-row">
          <span id="modalTeamBName" style="min-width:120px"></span>
          <div class="score-stepper">
            <button id="modalBTeamMinus" class="btn step" type="button" aria-label="Decrease goals">−</button>
            <input id="modalTeamBScore" class="score-input" type="number" inputmode="numeric" min="0" placeholder="0" aria-label="Team B goals" />
            <button id="modalBTeamPlus" class="btn step" type="button" aria-label="Increase goals">+</button>
          </div>
        </label>
      </div>
      <div style="display:flex; justify-content:space-between; align-items:center; gap:8px; margin-top:14px; padding-top:10px; border-top:1px solid var(--border)">
        <label class="switch">
          <input id="modalTrackScorers" type="checkbox" aria-label="Track player scorers for this match" />
          <span class="slider"></span>
          <span class="switch-text">Track player scorers for this match</span>
        </label>
        <div id="modalSaveError" class="notice error" style="display:none"></div>
      </div>
      <div id="modalScorers" class="scorers"></div>
    </div>
    <div class="modal-actions">
      <button id="modalCancel" type="button" class="btn">Cancel</button>
      <button id="modalSave" type="button" class="btn primary" disabled>Save</button>
    </div>
  </div>

  <!-- Modal for adding incidental player -->
  <div id="addPlayerModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="addPlayerTitle" hidden>
    <div class="modal-header">
      <h3 id="addPlayerTitle" style="margin:0; font-size:18px">Add Player</h3>
    </div>
    <div class="modal-body">
      <div class="modal-fields">
        <label style="flex-direction:column; align-items:stretch">
          <span class="notice" style="margin:0 0 6px 0">Enter a name that is not on the roster</span>
          <input id="addPlayerName" class="search" type="text" placeholder="Full name" aria-label="Player name" />
        </label>
        <label style="display:flex; align-items:center; justify-content:space-between; gap:12px">
          <span style="font-size:14px">Skill (1–5)</span>
          <div class="score-stepper">
            <button id="addPlayerSkillMinus" class="btn mini-step" type="button" aria-label="Decrease skill">−</button>
            <input id="addPlayerSkill" class="scorer-input" type="number" inputmode="numeric" min="1" max="5" step="1" value="3" aria-label="Skill level" />
            <button id="addPlayerSkillPlus" class="btn mini-step" type="button" aria-label="Increase skill">+</button>
          </div>
        </label>
        <div id="addPlayerError" class="notice error" style="display:none"></div>
      </div>
    </div>
    <div class="modal-actions">
      <button id="addPlayerCancel" type="button" class="btn">Cancel</button>
      <button id="addPlayerSave" type="button" class="btn primary" disabled>Save</button>
    </div>
  </div>

  <!-- Modal for reset confirmation -->
  <div id="resetModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="resetTitle" hidden>
    <div class="modal-header">
      <h3 id="resetTitle" style="margin:0; font-size:18px">Reset All?</h3>
    </div>
    <div class="modal-body">
      <div class="notice" style="font-weight:600">This clears attendees, teams, results, and rounds.</div>
    </div>
    <div class="modal-actions">
      <button id="resetCancel" type="button" class="btn">Cancel</button>
      <button id="resetConfirm" type="button" class="btn danger">Reset</button>
    </div>
  </div>

  <!-- Modal for choosing team count when n = 11 -->
  <div id="teamCountModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="teamCountTitle" hidden>
    <div class="modal-header">
      <h3 id="teamCountTitle" style="margin:0; font-size:18px">Choose Team Count</h3>
    </div>
    <div class="modal-body">
      <div class="notice" style="font-weight:600; margin-bottom:8px">You have 11 players. Do you want 2 teams or 3 teams?</div>
      <div class="notice">Choose 3 teams to play 4‑4‑3.</div>
    </div>
    <div class="modal-actions">
      <button id="teamCount2" type="button" class="btn">2 Teams</button>
      <button id="teamCount3" type="button" class="btn primary">3 Teams</button>
    </div>
  </div>

  <script>
    // ----- Data & Storage -----
    const DEFAULT_PLAYERS = [
      "Ruben","Job","Ramtin","Thijs","Emiel","Frits","Gerjan","Wout","Aklilu","Aron","Aurant","Bas","Bjorn","Danny","David","Hanno","Jefta","Lenn","Nathan","Rene","Sem","Timo","Wijnand","Willem","Amir","Ralph"
    ];

    const COLORS = [
      { name: "Green",  hex: "#10B981" },
      { name: "Blue",   hex: "#3B82F6" },
      { name: "Orange", hex: "#F59E0B" },
      { name: "Grey",   hex: "#6B7280" },
    ];

    // Skill levels (0-5). Adjust in code here when needed.
    const SKILLS = {
      Ruben: 4,
      Job: 4,
      Ramtin: 2,
      Thijs: 4,
      Emiel: 4,
      Frits: 3,
      Gerjan: 3,
      Wout: 3,
      Aklilu: 1,
      Aron: 1,
      Aurant: 2,
      Bas: 4,
      Bjorn: 4,
      Danny: 3,
      David: 3,
      Hanno: 5,
      Jefta: 3,
      Lenn: 3,
      Nathan: 3,
      Rene: 4,
      Sem: 5,
      Timo: 3,
      Wijnand: 3,
      Willem: 4,
      Amir: 4,
      Ralph: 5,
    };
    const DEFAULT_SKILL = 3; // for incidental players
    const getSkill = (name) => (typeof SKILLS[name] === 'number' ? SKILLS[name] : DEFAULT_SKILL);

    const KEYS = {
      players: 'futsal.players',
      attendees: 'futsal.match.attendees',
      teams: 'futsal.match.teams',
      timestamp: 'futsal.match.timestamp',
      results: 'futsal.match.results',
      rounds: 'futsal.match.rounds',
      prefTrackScorers: 'futsal.pref.trackScorers',
      prevRanks: 'futsal.leaderboard.prevRanks'
    };

    const state = {
      players: [],
      attendees: [],
      teams: [],
      timestamp: null,
      results: {}, // matchId -> {a:idA, b:idB, round:1..N, ga:number|null, gb:number|null}
      rounds: 2,
      celebrated: false,
      prevRanks: {}
    };

    function loadState(){
      const p = localStorage.getItem(KEYS.players);
      if(!p){
        localStorage.setItem(KEYS.players, JSON.stringify(DEFAULT_PLAYERS));
        state.players = [...DEFAULT_PLAYERS];
      } else {
        try{ state.players = JSON.parse(p) || []; }catch{ state.players = [...DEFAULT_PLAYERS]; }
      }

      try{ state.attendees = JSON.parse(localStorage.getItem(KEYS.attendees) || '[]'); }catch{ state.attendees = []; }
      try{ state.teams = JSON.parse(localStorage.getItem(KEYS.teams) || '[]'); }catch{ state.teams = []; }
      const ts = localStorage.getItem(KEYS.timestamp);
      state.timestamp = ts ? Number(ts) : null;
      try{ state.results = JSON.parse(localStorage.getItem(KEYS.results) || '{}'); }catch{ state.results = {}; }
      const rd = localStorage.getItem(KEYS.rounds);
      state.rounds = rd ? Math.max(1, parseInt(rd, 10) || 2) : 2;
      state.prevRanks = getPrevRanks();
    }

    function saveAttendees(){ localStorage.setItem(KEYS.attendees, JSON.stringify(state.attendees)); }
    function saveTeams(){ localStorage.setItem(KEYS.teams, JSON.stringify(state.teams)); }
    function saveTimestamp(){ if(state.timestamp) localStorage.setItem(KEYS.timestamp, String(state.timestamp)); }
    function saveResults(){ localStorage.setItem(KEYS.results, JSON.stringify(state.results)); }
    function saveRounds(){ localStorage.setItem(KEYS.rounds, String(state.rounds)); }
    function getTrackScorersPref(){
      const v = localStorage.getItem(KEYS.prefTrackScorers);
      return v === null ? false : v === 'true';
    }
    function setTrackScorersPref(on){ localStorage.setItem(KEYS.prefTrackScorers, on ? 'true' : 'false'); }
    function getPrevRanks(){
      try{ return JSON.parse(localStorage.getItem(KEYS.prevRanks) || '{}'); }catch{ return {}; }
    }
    function savePrevRanksFromRows(rows){
      const obj = {};
      rows.forEach((r, idx)=>{ obj[r.team.id] = idx; });
      localStorage.setItem(KEYS.prevRanks, JSON.stringify(obj));
    }

    // ----- Utilities -----
    function mulberry32(a){
      return function(){
        let t = a += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      }
    }

    // Stable time-windowed seeding: same attendees within window -> same seed
    const STABLE_WINDOW_MS = 60 * 60 * 1000; // 1 hour
    function fnv1a32(str){
      let h = 0x811c9dc5>>>0;
      for(let i=0;i<str.length;i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 0x01000193);
      }
      return h>>>0;
    }
    function computeStableSeedFromAttendees(attendees){
      const bucket = Math.floor(Date.now()/STABLE_WINDOW_MS);
      const key = attendees.slice().sort((a,b)=>a.localeCompare(b)).join('|') + '|' + bucket;
      return fnv1a32(key);
    }

    function shuffleSeeded(arr, seed){
      const rng = mulberry32(seed >>> 0);
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(rng() * (i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function clampPlayLimit(){
      const over = state.attendees.length > 16;
      if(over){
        state.attendees = state.attendees.slice(0,16);
        saveAttendees();
      }
      const notice = document.getElementById('limitNotice');
      if(state.attendees.length >= 16){
        notice.style.display = '';
      } else {
        notice.style.display = 'none';
      }
    }

    // ----- Rendering -----
    function renderRoster(){
      const listNot = document.getElementById('listNot');
      const listPlay = document.getElementById('listPlay');
      listNot.innerHTML = ''; listPlay.innerHTML='';

      const playSet = new Set(state.attendees);
      const notPlaying = state.players
        .filter(p => !playSet.has(p))
        .sort((a,b)=> a.localeCompare(b, undefined, { sensitivity: 'base' }));
      const notFiltered = notPlaying;

      // Available players list
      for(const name of notFiltered){
        const item = createListItem(name, false);
        listNot.appendChild(item);
      }
      // Playing list
      for(const name of state.attendees){
        const item = createListItem(name, true);
        listPlay.appendChild(item);
      }

      document.getElementById('countNot').textContent = `(${notPlaying.length})`;
      document.getElementById('countPlay').textContent = `(${state.attendees.length}/16)`;

      const hasTeams = state.teams && state.teams.length>0;
      const canGen = state.attendees.length >= 8 && !hasTeams;
      document.getElementById('btnGenerateBottom').disabled = !canGen;
      const addBtn = document.getElementById('btnAddPlayer');
      if(addBtn) addBtn.disabled = !!hasTeams;
      const info = document.getElementById('genError');
      if(hasTeams){
        info.classList.remove('error');
        info.style.display = '';
        info.textContent = 'Players are locked because teams are generated. Tap Reset to start over.';
      } else {
        info.textContent = '';
        info.style.display = 'none';
      }
      const sec = document.getElementById('playersSection');
      sec.classList.toggle('locked', !!hasTeams);
      const banner = document.getElementById('playersLockedMsg');
      if(hasTeams){
        banner.textContent = 'Players are locked — teams have been generated. Tap Reset to start over.';
      } else {
        banner.textContent = '';
      }
    }

    function createListItem(name, isPlaying){
      const div = document.createElement('div');
      div.className = 'item';
      div.setAttribute('role','listitem');
      const locked = state.teams && state.teams.length>0;
      div.setAttribute('draggable', locked ? 'false' : 'true');
      div.dataset.name = name;
      div.dataset.side = isPlaying ? 'playing' : 'not';

      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'move';
      btn.ariaLabel = (isPlaying? 'Remove ' : 'Add ') + name + (isPlaying? ' from Playing' : ' to Playing');
      btn.title = (locked ? 'Teams are generated. Reset to change players.' : (isPlaying? 'Move back' : 'Move to Playing'));
      if(locked) btn.disabled = true;
      btn.textContent = isPlaying ? '←' : '→';

      const label = document.createElement('div');
      label.textContent = name;
      label.style.flex = '1';

      // Click anywhere on item toggles
      div.tabIndex = 0;
      const onToggle = () => {
        if(state.teams && state.teams.length>0) return; // locked
        if(isPlaying){ moveToNot(name); } else { moveToPlay(name); }
      };
      div.addEventListener('click', (e)=>{
        if(e.target === btn) return; // button handles its own
        onToggle();
      });
      div.addEventListener('keydown', (e)=>{
        if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); onToggle(); }
      });
      btn.addEventListener('click', onToggle);

      // Drag & drop
      div.addEventListener('dragstart', (e)=>{
        if(state.teams && state.teams.length>0){ e.preventDefault(); return; }
        e.dataTransfer.setData('text/plain', name);
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('application/x-side', isPlaying ? 'playing' : 'not');
      });

      div.appendChild(label);
      div.appendChild(btn);
      return div;
    }

    function setupDnD(){
      const listNot = document.getElementById('listNot');
      const listPlay = document.getElementById('listPlay');
      const zones = [listNot, listPlay];
      for(const z of zones){
        z.addEventListener('dragover', (e)=>{ if(state.teams && state.teams.length>0) return; e.preventDefault(); z.classList.add('droptarget'); });
        z.addEventListener('dragleave', ()=> z.classList.remove('droptarget'));
        z.addEventListener('drop', (e)=>{
          if(state.teams && state.teams.length>0) return;
          e.preventDefault(); z.classList.remove('droptarget');
          const name = e.dataTransfer.getData('text/plain');
          const from = e.dataTransfer.getData('application/x-side');
          if(!name) return;
          if(z === listPlay){
            if(from !== 'playing') moveToPlay(name);
          } else {
            if(from === 'playing') moveToNot(name);
          }
        });
      }
    }

    function renderTeams(){
      const section = document.getElementById('teamsSection');
      const tbody = document.getElementById('teamsBody');
      tbody.innerHTML = '';
      if(!state.teams || state.teams.length === 0){
        // No teams yet: leave table empty
        return;
      }
      for(const team of state.teams){
        const tr = document.createElement('tr');
        const tdTeam = document.createElement('td');
        const pill = document.createElement('span');
        pill.className = 'team-pill';
        pill.style.borderColor = team.color;
        const nameSpan = document.createElement('span');
        nameSpan.className = 'team-name';
        nameSpan.contentEditable = 'true';
        nameSpan.textContent = team.name;
        nameSpan.dataset.teamId = String(team.id);
        nameSpan.ariaLabel = `Edit name for ${team.name}`;
        nameSpan.addEventListener('keydown', (e)=>{
          if(e.key === 'Enter'){ e.preventDefault(); nameSpan.blur(); }
        });
        nameSpan.addEventListener('blur', ()=>{
          const val = (nameSpan.textContent || '').trim();
          team.name = val || team.name; // keep previous if blank
          saveTeams();
          renderSchedule();
        });
        pill.appendChild(nameSpan);
        tdTeam.appendChild(pill);

        const tdMembers = document.createElement('td');
        tdMembers.textContent = team.members.join(', ');

        const tdSize = document.createElement('td');
        tdSize.textContent = String(team.members.length);

        tr.appendChild(tdTeam); tr.appendChild(tdMembers); tr.appendChild(tdSize);
        tbody.appendChild(tr);
      }
      renderSchedule();
    }

    function renderSchedule(){
      const schedSec = document.getElementById('matchesSection');
      const list = document.getElementById('matchesList');
      list.innerHTML = '';
      if(!state.teams || state.teams.length < 2){
        const info = document.createElement('div');
        info.className = 'notice';
        info.textContent = 'Generate teams to see the match schedule.';
        list.appendChild(info);
        return;
      }
      const stableSeed = computeStableSeedFromAttendees(state.attendees || []);
      const pairings = [];
      for(let i=0;i<state.teams.length;i++){
        for(let j=i+1;j<state.teams.length;j++){
          pairings.push([state.teams[i], state.teams[j]]);
        }
      }
      const totalRounds = Math.max(1, Number(state.rounds) || 2);
      let nextMarked = false;
      // Keep track of consecutive appearances across rounds to avoid 3 in a row
      const streak = new Map(state.teams.map(t => [t.id, 0]));
      const flat = [];
      for(let roundIdx=0; roundIdx<totalRounds; roundIdx++){
        // Order the pairings for this round to avoid 3+ consecutive matches for any team
        const ordered = orderRoundPairings(pairings, streak, stableSeed + roundIdx*1013);
        // accumulate flat list to compute kickoff fairness
        for(const [a,b] of ordered){
          const matchId = `${Math.min(a.id,b.id)}-${Math.max(a.id,b.id)}-r${roundIdx+1}`;
          flat.push({ a, b, roundIdx, matchId });
        }
        // We will render below after computing kickoff for next match
      }

      // Compute kickoff for the next unplayed match to balance starts evenly
      const startCounts = new Map(state.teams.map(t => [t.id, 0]));
      let nextKickoffId = null;
      const rng = mulberry32((stableSeed + 0x9e3779b9) >>> 0);
      let nextIndex = -1;
      for(let i=0;i<flat.length;i++){
        const { a, b, matchId } = flat[i];
        const rec = state.results[matchId];
        const played = rec && rec.ga != null && rec.gb != null;
        if(!played && nextIndex === -1){ nextIndex = i; break; }
        // assign historical kickoff deterministically for balancing, even if not stored
        const ca = startCounts.get(a.id) || 0;
        const cb = startCounts.get(b.id) || 0;
        let starter = null;
        if(ca < cb) starter = a.id; else if(cb < ca) starter = b.id; else starter = (rng() < 0.5 ? a.id : b.id);
        startCounts.set(starter, (startCounts.get(starter) || 0) + 1);
      }
      if(nextIndex >= 0){
        const { a, b } = flat[nextIndex];
        const ca = startCounts.get(a.id) || 0;
        const cb = startCounts.get(b.id) || 0;
        if(ca < cb) nextKickoffId = a.id; else if(cb < ca) nextKickoffId = b.id; else nextKickoffId = (rng() < 0.5 ? a.id : b.id);
      }

      // Now render rounds using the already prepared ordered/streak process again
      // Reset streak and iterate to produce the same ordered sequence
      streak.clear(); for(const t of state.teams){ streak.set(t.id, 0); }
      let flatCursor = 0;
      for(let roundIdx=0; roundIdx<totalRounds; roundIdx++){
        // Add round heading now, followed by its matches
        const h = document.createElement('div');
        h.style.marginTop = roundIdx === 0 ? '0' : '12px';
        h.style.fontWeight = '700';
        h.style.color = 'var(--muted)';
        h.textContent = `Round ${roundIdx+1}`;
        list.appendChild(h);
        const ordered = orderRoundPairings(pairings, streak, stableSeed + roundIdx*1013);
        ordered.forEach(([a,b]) => {
          const matchId = `${Math.min(a.id,b.id)}-${Math.max(a.id,b.id)}-r${roundIdx+1}`;
          const rec = state.results[matchId] || null;

          const row = document.createElement('div');
          row.className = 'pair';
          row.style.display = 'flex';
          row.style.flexWrap = 'wrap';
          row.style.gap = '8px 12px';
          row.style.alignItems = 'center';

          const label = document.createElement('div');
          label.style.flex = '1 1 220px';
          label.style.display = 'flex';
          label.style.gap = '8px';
          label.style.flexWrap = 'nowrap';
          label.style.flexDirection = 'column';
          label.style.alignItems = 'flex-start';
          const teamABox = document.createElement('div');
          teamABox.style.display = 'flex';
          teamABox.style.flexDirection = 'column';
          teamABox.style.alignItems = 'flex-start';
          const pillA = document.createElement('span');
          pillA.className = 'team-pill';
          pillA.style.borderColor = a.color;
          pillA.appendChild(document.createTextNode(a.name));
          const subA = document.createElement('div');
          subA.className = 'team-sub';
          subA.textContent = (a.members || []).join(', ');
          teamABox.appendChild(pillA);
          teamABox.appendChild(subA);
          teamABox.classList.add('match-team','a');
          // Removed explicit 'vs' label for cleaner layout
          const teamBBox = document.createElement('div');
          teamBBox.style.display = 'flex';
          teamBBox.style.flexDirection = 'column';
          teamBBox.style.alignItems = 'flex-start';
          const pillB = document.createElement('span');
          pillB.className = 'team-pill';
          pillB.style.borderColor = b.color;
          pillB.appendChild(document.createTextNode(b.name));
          const subB = document.createElement('div');
          subB.className = 'team-sub';
          subB.textContent = (b.members || []).join(', ');
          teamBBox.appendChild(pillB);
          teamBBox.appendChild(subB);
          teamBBox.classList.add('match-team','b');
          label.appendChild(teamABox);
          label.appendChild(teamBBox);

          const score = document.createElement('div');
          score.className = 'match-score';
          score.style.minWidth = '90px';
          score.style.fontWeight = '600';
          const isPlayed = rec && rec.ga != null && rec.gb != null;
          score.style.color = isPlayed ? '#111827' : 'var(--muted)';
          score.textContent = '';
          if(isPlayed){ row.classList.add('played'); }
          // Insert Next match heading above the first unplayed match and emphasize the card
          if(!isPlayed && !nextMarked){
            const head = document.createElement('div');
            head.className = 'next-heading';
            head.textContent = 'Next Match';
            list.appendChild(head);
            row.classList.add('next');
            nextMarked = true;
            // Show kickoff indicator only on the first upcoming match
            if(nextKickoffId != null){
              if(nextKickoffId === a.id){
                const ball = document.createElement('span');
                ball.textContent = ' ⚽️';
                pillA.appendChild(ball);
              } else if(nextKickoffId === b.id){
                const ball = document.createElement('span');
                ball.textContent = ' ⚽️';
                pillB.appendChild(ball);
              }
            }
          }
          // Winner styling: solid team-color pill with white text
          if(isPlayed){
            if(rec.ga > rec.gb){
              pillA.classList.add('winner');
              pillA.style.background = a.color; pillA.style.borderColor = a.color; pillA.style.color = '#fff';
            } else if(rec.gb > rec.ga){
              pillB.classList.add('winner');
              pillB.style.background = b.color; pillB.style.borderColor = b.color; pillB.style.color = '#fff';
            }
          }

          // Button handling: show score as a button when played; otherwise show Set Result
          if(isPlayed){
            const scoreBtn = document.createElement('button');
            scoreBtn.type = 'button';
            scoreBtn.className = 'btn slim';
            scoreBtn.textContent = `${rec.ga} - ${rec.gb}`;
            scoreBtn.addEventListener('click', ()=> openResultModal({ matchId, a, b, round: roundIdx+1 }));
            score.appendChild(scoreBtn);
          } else {
            const setBtn = document.createElement('button');
            setBtn.type = 'button';
            setBtn.className = 'btn slim';
            setBtn.textContent = 'Set Result';
            setBtn.addEventListener('click', ()=> openResultModal({ matchId, a, b, round: roundIdx+1 }));
            score.appendChild(setBtn);
          }
          // Players are always shown; no toggle button

          row.appendChild(label);
          row.appendChild(score);
          list.appendChild(row);
          flatCursor++;
        });
      }
      // Add bottom "Add additional round" button
      const addWrap = document.createElement('div');
      addWrap.style.margin = '12px 0 0 0';
      addWrap.style.display = 'flex';
      addWrap.style.justifyContent = 'flex-end';
      const addBtn = document.createElement('button');
      addBtn.type = 'button'; addBtn.className = 'btn'; addBtn.textContent = 'Add additional round';
      addBtn.addEventListener('click', addAdditionalRound);
      addWrap.appendChild(addBtn);
      list.appendChild(addWrap);
    }

    // Order pairings within a round to avoid any team playing 3 matches in a row across the schedule
    function orderRoundPairings(pairs, streakMap, seed){
      const rng = mulberry32((seed >>> 0));
      // Shuffle a copy to vary the base order deterministically
      const remaining = [...pairs].sort(() => rng() - 0.5);
      const ordered = [];
      const teamIds = state.teams.map(t => t.id);
      while(remaining.length){
        let pickIdx = -1;
        for(let i=0;i<remaining.length;i++){
          const aId = remaining[i][0].id, bId = remaining[i][1].id;
          const sa = streakMap.get(aId) || 0;
          const sb = streakMap.get(bId) || 0;
          if(sa < 2 && sb < 2){ pickIdx = i; break; }
        }
        if(pickIdx === -1){
          // Fallback: pick the first; we will still ensure not to exceed constraint by trying simple swap with previous
          pickIdx = 0;
        }
        const [a,b] = remaining.splice(pickIdx,1)[0];
        ordered.push([a,b]);
        // Update streaks: participants +1, others reset
        for(const id of teamIds){
          if(id === a.id || id === b.id){ streakMap.set(id, (streakMap.get(id)||0) + 1); }
          else { streakMap.set(id, 0); }
        }
      }
      return ordered;
    }

    function renderLeaderboard(){
      const lb = document.getElementById('leaderboardSection');
      lb.innerHTML = '';
      if(!state.teams || state.teams.length === 0){
        const info = document.createElement('div');
        info.className = 'notice';
        info.textContent = 'Generate teams to see the leaderboard.';
        lb.appendChild(info);
        return;
      }

      const title = document.createElement('h2');
      title.textContent = 'Leaderboard';
      title.style.margin = '16px 0 8px 0';
      lb.appendChild(title);

      // Compute points per team
      const byId = new Map(state.teams.map(t => [t.id, { team: t, pts: 0, played: 0, gf: 0, ga: 0 }]));
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key];
        if(!r) continue;
        const { a, b, ga, gb } = r;
        if(ga === null || gb === null || ga === undefined || gb === undefined) continue;
        const A = byId.get(a); const B = byId.get(b);
        if(!A || !B) continue;
        A.played++; B.played++;
        A.gf += ga; B.gf += gb;
        A.ga += gb; B.ga += ga;
        if(ga > gb){ A.pts += 3; }
        else if(gb > ga){ B.pts += 3; }
        else { A.pts += 1; B.pts += 1; }
      }
      const rows = Array.from(byId.values()).sort((x,y)=> y.pts - x.pts || y.gf - x.gf || x.team.name.localeCompare(y.team.name));

      const tournamentComplete = areAllMatchesScored();
      const prevRanks = getPrevRanks();
      // Winner banner if tournament complete
      if(tournamentComplete && rows.length){
        const top = rows[0];
        const win = document.createElement('div');
        win.className = 'winner-banner';
        win.textContent = `WINNER: ${top.team.name.toUpperCase()}!!`;
        lb.appendChild(win);
        if(!state.celebrated){
          celebrateWinner();
          state.celebrated = true;
        }
      }

      const wrap = document.createElement('div');
      wrap.style.overflow = 'auto';
      const table = document.createElement('table');
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th style="width:50%">Team</th><th>Played</th><th>Points</th><th>GD</th></tr>';
      const tbody = document.createElement('tbody');
      const winningTeamId = (tournamentComplete && rows.length) ? rows[0].team.id : null;
      rows.forEach((r, idx)=>{
        const tr = document.createElement('tr');
        const tdTeam = document.createElement('td');
        const pill = document.createElement('span');
        pill.className = 'team-pill';
        pill.style.borderColor = r.team.color;
        const label = document.createElement('span');
        label.textContent = r.team.name;
        pill.appendChild(label);
        tdTeam.appendChild(pill);
        // Rank change indicator (compare against previous render ranks)
        const prev = prevRanks[String(r.team.id)];
        const curr = idx;
        if(prev !== undefined && prev !== curr){
          const arrow = document.createElement('span');
          arrow.style.marginLeft = '6px';
          arrow.style.fontWeight = '700';
          arrow.style.fontSize = '14px';
          if(prev > curr){ arrow.textContent = ' ▲'; arrow.style.color = 'var(--accent-2)'; }
          else { arrow.textContent = ' ▼'; arrow.style.color = 'var(--danger)'; }
          tdTeam.appendChild(arrow);
        }
        if(winningTeamId && r.team.id === winningTeamId){
          const trophy = document.createElement('span');
          trophy.textContent = ' 🏆';
          trophy.style.marginLeft = '6px';
          tdTeam.appendChild(trophy);
        }
        const membersSmall = document.createElement('div');
        membersSmall.className = 'team-sub';
        membersSmall.textContent = r.team.members.join(', ');
        tdTeam.appendChild(membersSmall);
        const tdPlayed = document.createElement('td');
        tdPlayed.textContent = String(r.played);
        const tdPts = document.createElement('td');
        tdPts.textContent = String(r.pts);
        const tdG = document.createElement('td');
        const gd = (r.gf - (r.ga || 0));
        tdG.textContent = String(gd);
        if(gd > 0) tdG.classList.add('gd-pos');
        else if(gd < 0) tdG.classList.add('gd-neg');
        tr.appendChild(tdTeam); tr.appendChild(tdPlayed); tr.appendChild(tdPts); tr.appendChild(tdG);
        tbody.appendChild(tr);
      });
      table.appendChild(thead); table.appendChild(tbody);
      wrap.appendChild(table);
      lb.appendChild(wrap);
      // Save current ranks for next comparison
      savePrevRanksFromRows(rows);

      // Top Scorers (only players with >=1 goal), with AVG (goals per match)
      const scorerTotals = new Map();
      const playedCounts = new Map();
      const teamById = new Map(state.teams.map(t => [t.id, t]));
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key]; if(!r) continue;
        const { a, b, ga, gb, gpa, gpb } = r || {};
        if(gpa){ for(const [name, n] of Object.entries(gpa)){ if(n>0){ scorerTotals.set(name, (scorerTotals.get(name)||0)+n); } } }
        if(gpb){ for(const [name, n] of Object.entries(gpb)){ if(n>0){ scorerTotals.set(name, (scorerTotals.get(name)||0)+n); } } }
        const played = ga != null && gb != null;
        if(played){
          const teamA = teamById.get(a); const teamB = teamById.get(b);
          if(teamA){ for(const name of teamA.members){ playedCounts.set(name, (playedCounts.get(name)||0)+1); } }
          if(teamB){ for(const name of teamB.members){ playedCounts.set(name, (playedCounts.get(name)||0)+1); } }
        }
      }
      const scorers = Array.from(scorerTotals.entries())
        .filter(([_,n])=> n>0)
        .sort((a,b)=> b[1]-a[1] || a[0].localeCompare(b[0]));
      if(scorers.length){
        const sTitle = document.createElement('h3'); sTitle.textContent = 'Top Scorers'; sTitle.style.margin = '12px 0 6px 0';
        lb.appendChild(sTitle);
        const sTable = document.createElement('table');
        const sHead = document.createElement('thead'); sHead.innerHTML = '<tr><th style="width:60%">Player</th><th>Goals</th><th>GPM</th></tr>';
        const sBody = document.createElement('tbody');
        const topGoals = scorers[0][1];
        for(const [name, goals] of scorers){
          const played = playedCounts.get(name) || 0;
          const avg = played ? (goals/played) : 0;
          const tr = document.createElement('tr');
          const tdN = document.createElement('td');
          tdN.textContent = name + ((tournamentComplete && goals === topGoals) ? ' 🏆' : '');
          const tdG = document.createElement('td'); tdG.textContent = String(goals);
          const tdAvg = document.createElement('td'); tdAvg.textContent = avg.toFixed(1);
          tr.appendChild(tdN); tr.appendChild(tdG); tr.appendChild(tdAvg); sBody.appendChild(tr);
        }
        sTable.appendChild(sHead); sTable.appendChild(sBody);
        lb.appendChild(sTable);
      }
    }

    function updateGenError(msg){
      const el = document.getElementById('genError');
      if(msg){ el.textContent = msg; el.style.display = ''; }
      else { el.textContent=''; el.style.display='none'; }
    }

    // ----- Modal: Set Result -----
    let modalCtx = null; // { matchId, aId, bId, round }
    function openResultModal({ matchId, a, b, round }){
      modalCtx = { matchId, aId: a.id, bId: b.id, round };
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('resultModal');
      const aName = document.getElementById('modalTeamAName');
      const bName = document.getElementById('modalTeamBName');
      const aInput = document.getElementById('modalTeamAScore');
      const bInput = document.getElementById('modalTeamBScore');
      const aMinus = document.getElementById('modalATeamMinus');
      const aPlus = document.getElementById('modalATeamPlus');
      const bMinus = document.getElementById('modalBTeamMinus');
      const bPlus = document.getElementById('modalBTeamPlus');
      const label = document.getElementById('modalMatchLabel');
      const saveBtn = document.getElementById('modalSave');

      // Render team pills in modal
      aName.textContent = '';
      bName.textContent = '';
      const pillA = document.createElement('span');
      pillA.className = 'team-pill';
      pillA.style.borderColor = a.color;
      pillA.appendChild(document.createTextNode(a.name));
      const pillB = document.createElement('span');
      pillB.className = 'team-pill';
      pillB.style.borderColor = b.color;
      pillB.appendChild(document.createTextNode(b.name));
      aName.appendChild(pillA);
      const subA = document.createElement('div');
      subA.className = 'team-sub';
      subA.textContent = (a.members || []).join(', ');
      aName.appendChild(subA);
      bName.appendChild(pillB);
      const subB = document.createElement('div');
      subB.className = 'team-sub';
      subB.textContent = (b.members || []).join(', ');
      bName.appendChild(subB);
      label.textContent = `${a.name} vs ${b.name} • Round ${round}`;

      const existing = state.results[matchId];
      aInput.value = existing && existing.ga != null ? existing.ga : '0';
      bInput.value = existing && existing.gb != null ? existing.gb : '0';

      function canSave(){ return aInput.value !== '' && bInput.value !== ''; }
      saveBtn.disabled = !canSave();
      const onInput = ()=>{ saveBtn.disabled = !canSave(); };
      aInput.oninput = onInput; bInput.oninput = onInput;

      overlay.hidden = false; modal.hidden = false;
      setTimeout(()=> aInput.focus(), 0);

      function escHandler(e){ if(e.key === 'Escape'){ closeResultModal(); } }
      document.addEventListener('keydown', escHandler, { once: true });

      document.getElementById('modalCancel').onclick = closeResultModal;
      overlay.onclick = closeResultModal;
      function step(input, delta){
        const cur = parseInt(input.value || '0', 10);
        let v = Number.isFinite(cur) ? cur : 0;
        v = Math.max(0, v + delta);
        input.value = String(v);
        onInput();
      }
      aMinus.onclick = ()=> step(aInput, -1);
      aPlus.onclick = ()=> step(aInput, +1);
      bMinus.onclick = ()=> step(bInput, -1);
      bPlus.onclick = ()=> step(bInput, +1);

      // ----- Per-player scorers -----
      const scorersWrap = document.getElementById('modalScorers');
      scorersWrap.innerHTML = '';
      const aCard = document.createElement('div'); aCard.className = 'scorer-card';
      const aTitle = document.createElement('div'); aTitle.className = 'scorer-title'; aTitle.textContent = `${a.name} scorers`;
      aCard.appendChild(aTitle);
      const bCard = document.createElement('div'); bCard.className = 'scorer-card';
      const bTitle = document.createElement('div'); bTitle.className = 'scorer-title'; bTitle.textContent = `${b.name} scorers`;
      bCard.appendChild(bTitle);
      scorersWrap.appendChild(aCard); scorersWrap.appendChild(bCard);

      const gpa = (existing && existing.gpa) ? existing.gpa : {};
      const gpb = (existing && existing.gpb) ? existing.gpb : {};
      const aInputs = new Map();
      const bInputs = new Map();
      function makeRow(name, initial, map, parent){
        const row = document.createElement('div'); row.className = 'scorer-row';
        const label = document.createElement('div'); label.textContent = name; label.style.flex='1';
        const minus = document.createElement('button'); minus.type='button'; minus.className='btn mini-step'; minus.textContent='−';
        const inp = document.createElement('input'); inp.type='number'; inp.min='0'; inp.inputMode='numeric'; inp.className='scorer-input'; inp.value = (initial ?? 0);
        const plus = document.createElement('button'); plus.type='button'; plus.className='btn mini-step'; plus.textContent='+';
        const change = (delta)=>{
          const v = Math.max(0, parseInt(inp.value||'0',10)+(delta||0));
          inp.value = String(v);
          syncIfTracking();
        };
        minus.onclick = ()=> change(-1);
        plus.onclick = ()=> change(+1);
        // independent inputs unless tracking is enabled
        inp.oninput = ()=> syncIfTracking();
        row.appendChild(label); row.appendChild(minus); row.appendChild(inp); row.appendChild(plus);
        parent.appendChild(row);
        map.set(name, inp);
      }
      for(const p of a.members){ makeRow(p, gpa[p] ?? 0, aInputs, aCard); }
      for(const p of b.members){ makeRow(p, gpb[p] ?? 0, bInputs, bCard); }

      // Toggle tracking visibility
      const trackToggle = document.getElementById('modalTrackScorers');
      const existingHasScorers = (Object.keys(gpa).length > 0 || Object.keys(gpb).length > 0);
      trackToggle.checked = existingHasScorers ? true : getTrackScorersPref();
      function sumMapVals(map){ let s=0; map.forEach((el)=>{ s += Math.max(0, parseInt(el.value||'0',10)); }); return s; }
      function updateTotalsFromPlayers(){
        const sa = sumMapVals(aInputs);
        const sb = sumMapVals(bInputs);
        const ca = Math.max(0, parseInt(aInput.value||'0',10));
        const cb = Math.max(0, parseInt(bInput.value||'0',10));
        // Only raise totals; never reduce below what user set
        const na = Math.max(ca, sa);
        const nb = Math.max(cb, sb);
        aInput.value = String(na);
        bInput.value = String(nb);
      }
      function syncIfTracking(){ if(trackToggle.checked){ updateTotalsFromPlayers(); onInput(); } }
      const applyToggle = ()=>{
        scorersWrap.style.display = trackToggle.checked ? '' : 'none';
        aInput.disabled = trackToggle.checked;
        bInput.disabled = trackToggle.checked;
        if(trackToggle.checked){ updateTotalsFromPlayers(); onInput(); }
      };
      applyToggle();
      trackToggle.onchange = ()=>{ applyToggle(); setTrackScorersPref(trackToggle.checked); };
      const saveError = document.getElementById('modalSaveError');
      saveBtn.onclick = () => {
        const ga = Math.max(0, parseInt(aInput.value, 10));
        const gb = Math.max(0, parseInt(bInput.value, 10));
        if(!Number.isFinite(ga) || !Number.isFinite(gb)) return;
        if(trackToggle.checked){
          let sa=0,sb=0; aInputs.forEach((el)=>{ sa += Math.max(0, parseInt(el.value||'0',10)); });
          bInputs.forEach((el)=>{ sb += Math.max(0, parseInt(el.value||'0',10)); });
          // Auto-raise totals if player sums surpass them; never decrease totals
          const finalA = Math.max(ga, sa);
          const finalB = Math.max(gb, sb);
          // Strict validation: if player sums are below totals, block save
          if(sa < finalA || sb < finalB){
            saveError.style.display='';
            saveError.textContent = `Distribute all goals to players: need ${finalA}-${finalB}, have ${sa}-${sb}.`;
            return;
          }
          saveError.style.display='none';
          const outA = {}; aInputs.forEach((el, name)=>{ const n = Math.max(0, parseInt(el.value||'0',10)); if(n>0) outA[name]=n; });
          const outB = {}; bInputs.forEach((el, name)=>{ const n = Math.max(0, parseInt(el.value||'0',10)); if(n>0) outB[name]=n; });
          state.results[matchId] = { a: modalCtx.aId, b: modalCtx.bId, round: modalCtx.round, ga: finalA, gb: finalB, gpa: outA, gpb: outB };
        } else {
          saveError.style.display='none';
          state.results[matchId] = { a: modalCtx.aId, b: modalCtx.bId, round: modalCtx.round, ga, gb };
        }
        saveResults();
        closeResultModal();
        renderSchedule();
        renderLeaderboard();
        if(areAllMatchesScored() && !state.celebrated){
          switchTab('leaderboard');
          celebrateWinner();
          state.celebrated = true;
        }
      };
    }

    function closeResultModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('resultModal');
      overlay.hidden = true; modal.hidden = true; modalCtx = null;
    }

    // ----- Modal: Add Player -----
    function openAddPlayerModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('addPlayerModal');
      const input = document.getElementById('addPlayerName');
      const skillInput = document.getElementById('addPlayerSkill');
      const skillMinus = document.getElementById('addPlayerSkillMinus');
      const skillPlus = document.getElementById('addPlayerSkillPlus');
      const err = document.getElementById('addPlayerError');
      const save = document.getElementById('addPlayerSave');
      const cancel = document.getElementById('addPlayerCancel');

      err.style.display = 'none';
      err.textContent = '';
      input.value = '';
      skillInput.value = '3';
      save.disabled = true;

      function update(){ save.disabled = input.value.trim().length === 0; }
      input.oninput = update;
      function clampSkill(v){
        const n = Math.max(1, Math.min(5, parseInt(v||'3',10)));
        return Number.isFinite(n) ? n : 3;
      }
      skillMinus.onclick = ()=>{ skillInput.value = String(clampSkill((parseInt(skillInput.value||'3',10) - 1))); };
      skillPlus.onclick = ()=>{ skillInput.value = String(clampSkill((parseInt(skillInput.value||'3',10) + 1))); };
      skillInput.oninput = ()=>{ skillInput.value = String(clampSkill(skillInput.value)); };

      overlay.hidden = false; modal.hidden = false; setTimeout(()=> input.focus(), 0);
      overlay.onclick = closeAddPlayerModal;
      cancel.onclick = closeAddPlayerModal;
      document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ closeAddPlayerModal(); } }, { once:true });

      save.onclick = ()=>{
        const name = input.value.trim();
        if(!name){ return; }
        if(state.attendees.length >= 16){
          err.textContent = 'Cannot add more than 16 attendees.';
          err.style.display = '';
          return;
        }
        // If matches existing roster name (case-insensitive), use canonical name
        const match = state.players.find(p => p.toLowerCase() === name.toLowerCase());
        const finalName = match || name;
        // Prevent duplicates in attendees
        if(state.attendees.some(a => a.toLowerCase() === finalName.toLowerCase())){
          err.textContent = 'That player is already in Playing Today.';
          err.style.display = '';
          return;
        }
        // Assign provided skill for incidental players not in the predefined list
        if(typeof SKILLS[finalName] !== 'number'){
          SKILLS[finalName] = clampSkill(skillInput.value);
        }
        state.attendees.push(finalName);
        saveAttendees();
        closeAddPlayerModal();
        clampPlayLimit();
        renderRoster();
        updateTabsUI();
      };
    }
    function closeAddPlayerModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('addPlayerModal');
      overlay.hidden = true; modal.hidden = true;
    }

    // ----- Modal: Reset Confirmation -----
    function openResetModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('resetModal');
      const cancel = document.getElementById('resetCancel');
      const confirm = document.getElementById('resetConfirm');

      overlay.hidden = false; modal.hidden = false;
      overlay.onclick = closeResetModal;
      cancel.onclick = closeResetModal;
      confirm.onclick = () => { closeResetModal(); resetAll(); };
      document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ closeResetModal(); } }, { once:true });
    }
    function closeResetModal(){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('resetModal');
      overlay.hidden = true; modal.hidden = true;
    }

    // ----- Modal: Choose team count when n=11 -----
    function openTeamCountModal(options=[2,3], nOverride){
      const overlay = document.getElementById('overlay');
      const modal = document.getElementById('teamCountModal');
      const btn2 = document.getElementById('teamCount2');
      const btn3 = document.getElementById('teamCount3');
      overlay.hidden = false; modal.hidden = false;
      const body = modal.querySelector('.modal-body');
      const n = nOverride || state.attendees.length;
      const a = options[0], b = options[1];
      const sizesA = sizesDesc(n, a);
      const sizesB = sizesDesc(n, b);
      body.innerHTML = `<div class="notice" style="font-weight:600; margin-bottom:8px">You have ${n} players. Choose ${a} or ${b} teams.</div>
                        <div class="notice">${a} teams: ${sizesA} &nbsp; • &nbsp; ${b} teams: ${sizesB}</div>`;
      btn2.textContent = `${a} Teams`;
      btn3.textContent = `${b} Teams`;
      const close = ()=>{ overlay.hidden = true; modal.hidden = true; btn2.onclick = null; btn3.onclick = null; };
      overlay.onclick = close;
      document.addEventListener('keydown', function esc(e){ if(e.key==='Escape'){ close(); } }, { once:true });
      btn2.onclick = ()=>{ close(); generateTeamsOverride(a); };
      btn3.onclick = ()=>{ close(); generateTeamsOverride(b); };
    }

    function generateTeamsOverride(tOverride){
      const n = state.attendees.length;
      if(!state.timestamp){ state.timestamp = Date.now(); saveTimestamp(); }
      const t = tOverride;
      const stableSeed = computeStableSeedFromAttendees(state.attendees);
      const shuffled = shuffleSeeded(state.attendees, stableSeed);
      // Evenly distribute capacities for override
      const base = Array(t).fill(Math.floor(n/t));
      const r = n % t;
      for(let i=t-r; i<t; i++) if(i>=0 && i<t) base[i] += 1;
      const colors = COLORS.slice(0, Math.min(t, COLORS.length));
      const totalSkillOv = state.attendees.reduce((s, name)=> s + getSkill(name), 0);
      const avgSkillOv = totalSkillOv / n;
      const teamInfos = base.map((size, i) => ({
        cap: size,
        target: size * avgSkillOv,
        skillSum: 0,
        team: { id: i+1, name: colors[i].name, color: colors[i].hex, members: [] }
      }));
      const orderIndex = new Map(shuffled.map((name, idx) => [name, idx]));
      const playersSorted = [...state.attendees].sort((a,b)=>{
        const sa = getSkill(a), sb = getSkill(b);
        if(sb !== sa) return sb - sa;
        return (orderIndex.get(a) ?? 0) - (orderIndex.get(b) ?? 0);
      });
      for(const player of playersSorted){
        const s = getSkill(player);
        let best = -1, bestDef = -Infinity;
        for(let i=0;i<teamInfos.length;i++){
          const info = teamInfos[i];
          if(info.team.members.length < info.cap){
            const def = info.target - info.skillSum;
            if(def > bestDef + 1e-9){ bestDef = def; best = i; }
            else if(Math.abs(def - bestDef) <= 1e-9 && best !== -1){
              const bi = teamInfos[best];
              if(info.team.members.length < bi.team.members.length) best = i;
              else if(info.team.members.length === bi.team.members.length && info.skillSum < bi.skillSum) best = i;
              else if(info.team.members.length === bi.team.members.length && info.skillSum === bi.skillSum && i < best) best = i;
            }
          }
        }
        if(best === -1) best = 0;
        const tgt = teamInfos[best];
        tgt.team.members.push(player);
        tgt.skillSum += s;
      }
      state.teams = teamInfos.map(x => x.team);
      state.results = {};
      state.rounds = 2;
      localStorage.removeItem(KEYS.prevRanks);
      saveTeams(); saveResults(); saveRounds();
      renderTeams(); renderRoster(); renderSchedule(); renderLeaderboard();
      switchTab('teams'); updateTabsUI();
    }

    // Compute a sizes descriptor string using even distribution (e.g., 11 with 2 -> 6-5, with 3 -> 4-4-3)
    function sizesDesc(n, t){
      const base = Array(t).fill(Math.floor(n/t));
      const r = n % t;
      for(let i=t-r; i<t; i++) if(i>=0 && i<t) base[i] += 1;
      // Present in descending order for readability (e.g., 6-5, 4-4-3, 4-4-4-3)
      return base.sort((a,b)=> b-a).join('-');
    }

    // ----- Actions -----
    function moveToPlay(name){
      if(state.attendees.includes(name)) return;
      if(state.attendees.length >= 16){
        clampPlayLimit();
        return;
      }
      state.attendees.push(name);
      saveAttendees();
      // keep teams if any? Spec doesn't forbid changing attendees post teams; leave teams intact.
      clampPlayLimit();
      renderRoster();
      updateTabsUI();
    }
    function moveToNot(name){
      const idx = state.attendees.indexOf(name);
      if(idx>=0){
        state.attendees.splice(idx,1);
        saveAttendees();
        clampPlayLimit();
        renderRoster();
        updateTabsUI();
      }
    }

    function resetAll(){
      state.attendees = [];
      state.teams = [];
      state.results = {};
      state.timestamp = Date.now();
      state.rounds = 2;
      saveAttendees();
      saveTeams();
      saveResults();
      saveTimestamp();
      saveRounds();
      updateGenError('');
      closeResultModal();
      renderRoster();
      renderTeams();
      renderSchedule();
      renderLeaderboard();
      switchTab('players');
      updateTabsUI();
    }

    function addAdditionalRound(){
      if(!state.teams || state.teams.length < 2) return;
      state.rounds = Math.max(1, Number(state.rounds) || 2) + 1;
      state.celebrated = false;
      saveRounds();
      renderSchedule();
    }

    // clearTeams replaced by resetAll (single reset action)

    function computeTeamCount(n){
      return Math.max(1, Math.min(4, Math.floor(n/4)));
    }

    function getPairings(){
      const pairs = [];
      if(!state.teams) return pairs;
      for(let i=0;i<state.teams.length;i++){
        for(let j=i+1;j<state.teams.length;j++){
          pairs.push([state.teams[i], state.teams[j]]);
        }
      }
      return pairs;
    }

    function areAllMatchesScored(){
      if(!state.teams || state.teams.length < 2) return false;
      const pairings = getPairings();
      const rounds = Math.max(1, Number(state.rounds) || 2);
      for(let r=1;r<=rounds;r++){
        for(const [a,b] of pairings){
          const id = `${Math.min(a.id,b.id)}-${Math.max(a.id,b.id)}-r${r}`;
          const rec = state.results[id];
          if(!rec || rec.ga == null || rec.gb == null) return false;
        }
      }
      return true;
    }

    function celebrateWinner(){
      // Compute top team like leaderboard
      const byId = new Map(state.teams.map(t => [t.id, { team: t, pts: 0, played: 0, gf: 0 }]));
      for(const key of Object.keys(state.results || {})){
        const r = state.results[key];
        if(!r) continue;
        const { a, b, ga, gb } = r;
        if(ga == null || gb == null) continue;
        const A = byId.get(a); const B = byId.get(b);
        if(!A || !B) continue;
        A.played++; B.played++;
        A.gf += ga; B.gf += gb;
        if(ga > gb){ A.pts += 3; } else if(gb > ga){ B.pts += 3; } else { A.pts += 1; B.pts += 1; }
      }
      const rows = Array.from(byId.values()).sort((x,y)=> y.pts - x.pts || y.gf - x.gf || x.team.name.localeCompare(y.team.name));
      const winner = rows.length ? rows[0].team.name : 'Winner';
      showToast(`🎉 WINNER: ${winner.toUpperCase()}!!`, 'winner');
      launchConfetti();
    }

    function showToast(text, extraClass){
      const t = document.createElement('div');
      t.className = 'toast' + (extraClass ? (' ' + extraClass) : '');
      t.setAttribute('role','status');
      t.setAttribute('aria-live','polite');
      t.innerHTML = `<span class="emoji">🎉</span><span>${text}</span>`;
      document.body.appendChild(t);
      setTimeout(()=>{ t.remove(); }, 4000);
    }

    function launchConfetti(){
      const colors = ['#EF4444','#F59E0B','#10B981','#3B82F6','#8B5CF6','#EC4899'];
      const count = 80;
      const nodes = [];
      for(let i=0;i<count;i++){
        const c = document.createElement('div');
        c.className = 'confetti';
        const left = Math.random()*100;
        const dur = 2.8 + Math.random()*1.8;
        const delay = Math.random()*0.5;
        c.style.left = left + 'vw';
        c.style.background = colors[i % colors.length];
        c.style.animation = `confetti-fall ${dur}s linear ${delay}s forwards`;
        document.body.appendChild(c);
        nodes.push(c);
      }
      setTimeout(()=> nodes.forEach(n=> n.remove()), 5000);
    }

    function generateTeams(){
      const n = state.attendees.length;
      if(n < 8){
        updateGenError('Need at least 8 attendees to generate teams.');
        return;
      }
      updateGenError('');
      if(n === 11){
        return openTeamCountModal([2,3], 11);
      }
      if(n === 15){
        return openTeamCountModal([3,4], 15);
      }
      if(!state.timestamp){ state.timestamp = Date.now(); saveTimestamp(); }

      const t = computeTeamCount(n);
      const stableSeed = computeStableSeedFromAttendees(state.attendees);
      const shuffled = shuffleSeeded(state.attendees, stableSeed);
      // target sizes: base 4, last r teams +1
      const base = Array(t).fill(4);
      const r = n - 4*t;
      for(let i=t-r; i<t; i++) if(i>=0 && i<t) base[i] += 1;

      const colors = COLORS.slice(0, Math.min(t, COLORS.length));
      // Build teams with capacity and targets based on average skill per slot
      const totalSkill = state.attendees.reduce((s, name)=> s + getSkill(name), 0);
      const avgSkill = totalSkill / n;
      const teamInfos = base.map((size, i) => ({
        cap: size,
        target: size * avgSkill,
        skillSum: 0,
        team: {
          id: i+1,
          name: colors[i].name,
          color: colors[i].hex,
          members: []
        }
      }));

      // Assign players sorted by skill desc (tie-broken by seeded shuffle)
      // Choose the team with the greatest deficit (target - currentSum), respecting capacity
      const orderIndex = new Map(shuffled.map((name, idx) => [name, idx]));
      const playersSorted = [...state.attendees].sort((a,b)=>{
        const sa = getSkill(a), sb = getSkill(b);
        if(sb !== sa) return sb - sa; // higher skill first
        return (orderIndex.get(a) ?? 0) - (orderIndex.get(b) ?? 0); // deterministic tie-breaker
      });
      for(const player of playersSorted){
        const s = getSkill(player);
        let best = -1;
        let bestDef = -Infinity;
        for(let i=0;i<teamInfos.length;i++){
          const info = teamInfos[i];
          if(info.team.members.length < info.cap){
            const def = info.target - info.skillSum;
            if(def > bestDef + 1e-9){ bestDef = def; best = i; }
            else if(Math.abs(def - bestDef) <= 1e-9 && best !== -1){
              const bi = teamInfos[best];
              if(info.team.members.length < bi.team.members.length) best = i;
              else if(info.team.members.length === bi.team.members.length && info.skillSum < bi.skillSum) best = i;
              else if(info.team.members.length === bi.team.members.length && info.skillSum === bi.skillSum && i < best) best = i;
            }
          }
        }
        if(best === -1) best = 0;
        const tgt = teamInfos[best];
        tgt.team.members.push(player);
        tgt.skillSum += s;
      }

      state.teams = teamInfos.map(x => x.team);
      state.results = {};
      state.rounds = 2;
      saveTeams();
      saveResults();
      saveRounds();
      renderTeams();
      renderRoster();
      renderSchedule();
      renderLeaderboard();
      switchTab('teams');
      updateTabsUI();
    }

    function copyTeams(){
      if(!navigator.clipboard){ return; }
      const lines = [];
      for(const t of state.teams){
        lines.push(`${t.name}: ${t.members.join(', ')}`);
      }
      const txt = lines.join('\n');
      navigator.clipboard.writeText(txt).then(()=>{
        const btn = document.getElementById('btnCopy');
        if(btn){
          const old = btn.textContent; btn.textContent = 'Copied!';
          setTimeout(()=> btn.textContent = old, 1200);
        }
      });
    }

    // ----- Wire up -----
    document.getElementById('btnGenerateBottom').addEventListener('click', generateTeams);
    document.getElementById('btnReset').addEventListener('click', openResetModal);
    // Copy button removed from UI
    document.getElementById('btnAddPlayer').addEventListener('click', openAddPlayerModal);

    // Drop zones setup runs once; items are re-rendered each time
    setupDnD();

    // ----- Tabs -----
    const tabs = {
      players: document.getElementById('tabPlayers'),
      teams: document.getElementById('tabTeams'),
      matches: document.getElementById('tabMatches'),
      leaderboard: document.getElementById('tabLeaderboard'),
    };
    const panels = {
      players: document.getElementById('playersSection'),
      teams: document.getElementById('teamsSection'),
      matches: document.getElementById('matchesSection'),
      leaderboard: document.getElementById('leaderboardSection'),
    };
    let currentTab = 'players';
    function switchTab(which){
      const hasTeams = state.teams && state.teams.length > 0;
      if((which === 'teams' || which === 'matches' || which === 'leaderboard') && !hasTeams) return; // disabled
      currentTab = which;
      for(const [k,btn] of Object.entries(tabs)){
        const active = k === which;
        btn.classList.toggle('active', active);
        btn.setAttribute('aria-selected', active ? 'true' : 'false');
      }
      for(const [k,el] of Object.entries(panels)){
        el.hidden = k !== which;
      }
      if(which === 'players'){
        renderRoster(); // ensure lock state reflected immediately
      }
    }
    function updateTabsUI(){
      const hasTeams = state.teams && state.teams.length > 0;
      tabs.teams.disabled = !hasTeams;
      tabs.matches.disabled = !hasTeams;
      tabs.leaderboard.disabled = !hasTeams;
      if(!hasTeams && (currentTab === 'teams' || currentTab === 'matches' || currentTab === 'leaderboard')) switchTab('players');
    }
    tabs.players.addEventListener('click', ()=> switchTab('players'));
    tabs.teams.addEventListener('click', ()=> switchTab('teams'));
    tabs.matches.addEventListener('click', ()=> switchTab('matches'));
    tabs.leaderboard.addEventListener('click', ()=> switchTab('leaderboard'));

    // ----- Init -----
    loadState();
    // Initial UI
    renderRoster();
    renderTeams();
    renderSchedule();
    renderLeaderboard();
    clampPlayLimit();
    updateTabsUI();
    switchTab('players');
  </script>
</body>
</html>
